// Program that rolls dice for DnD variation Basements 
// and Byters

// Standard constants
$f 1
$w 0
$stack_size 16

// Registers
@cur_roll 0x09
@lfsr 0x0A
@stack_ptr 0x0F
@stack_start 0x10
@stack_end 0x1f

:origin
	// Setup io ports
	movlw 00011000b
	tris 6
	
	// Load lfsr with a seed
	movlw 0x79
	movwf lfsr

:press_start
	// Clear LED outputs and proceed when GP3 is
	// pressed and clear cur_roll
	clrf GPIO	
	btfsc GPIO, GP3
	goto press_start

:begin_roll
	// Display sequence on GPIO to inform user that 
	// we are rolling
	movlw 00100010b
	movwf GPIO
	
	// First clear the carry so that we know that it 
	// is zero. Now, shift the lfsr right putting
	// the LSB in carry and copying the lfsr into 
	// the working register for more processing 
	bcf STATUS,C
	rrf lfsr, w

	// If the carry (LSB) is set we want to xor the 
	// lfsr with our xor taps: 8,6,5,4(0,2,3,4)
	btfsc STATUS, C
	xorlw 10111000b
	movwf lfsr // save the new lfsr

	// continue rolling display sequence
	movlw 00000101b
	movwf GPIO
	
	// retrieve pseudo-random 16 bit number again 
	// since we moved rolling display bits above 
	// into working
	movf lfsr, w

:end_roll
	// Check the mode if GP3 is set (user has
	// stopped rolling). Otherwise proceed forward
	// to save_small_die.
	btfsc GPIO, GP3
	goto check_mode
	
:save_small_die
	// Mask 3 bits to save 8 sided die even if user
	// doesn't intend to roll 2 8 sided dice. This 
	// makes rolling 2 8 sided dice easier to 
	// implement
	andlw 111b
	movwf cur_roll
	goto begin_roll

:check_mode
	// Clear GPIO to inform user that rolling has 
	// stopped, then check the mode and proceed to 
	// appropriate subroutine according to mode from 
	// GP4
	clrf GPIO
	btfsc GPIO, GP4
	goto one_die
	goto second_dice

:one_die
	// When user wants one die, mask lower 4 bits 
	// and save it so we can display properly
	andlw 1111b
	movwf cur_roll
	goto display_roll

:second_dice
	// When user wants two dice, mask lower 3 bits 
	// and add with previous roll generated by LFSR 
	// and by saveing 3 bit masks after every new 
	// number generated from the lfsr
	andlw 111b
	addwf cur_roll, f

:display_roll
	// Because we can not bit test from working 
	// register, we must read from cur_roll register 
	// as well as bring to working to inclusive or 
	// with 5th bit if 3rd bit is set. We then move 
	// to GPIO. We must do this because GP5 is 
	// outputting the 3rd bit. 
	movf cur_roll, w
	btfsc cur_roll, 3
	iorlw 00100000b
	movwf GPIO

:stack
	// If stack_ptr - stack_size = 0 then we are at 
	// end of stack as we have incremented the 
	// pointer all the up through the stack. 
	// Therefore we check zero bit of STATUS. If we 
	// are at end of stack then reset stack_ptr back 
	// to 0
	movlw stack_size
	subwf stack_ptr, w
	btfsc STATUS, Z
	movlw 0
	btfsc STATUS, Z
	movwf stack_ptr

	// add stack_ptr to stack_start to get correct 
	// address to store current roll and store that 
	// address in FSR
	movlw stack_start
	addwf stack_ptr, w
	movwf FSR
	
	// Store roll in correct location in circular 
	// buffer by moving current roll into INDF. 
	// Increment stack_ptr to continue down the 
	// stack on next roll 
	movf cur_roll, w
	movwf INDF
	incf stack_ptr, f

:wait_for_release
	// Wait until switch is released
	btfss GPIO, GP3
	goto wait_for_release
	goto press_start